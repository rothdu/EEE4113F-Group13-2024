% ----------------------------------------------------
% Firmware Submodule
% ----------------------------------------------------
\chapter{Firmware development \label{ch:firmware}}
\section{Subsystem introduction}

This subsystem deals with the development of firmware for the microcontrollers in both the camera/transmitter and receiver modules. The fundamental goals of this subsystem are to enable the camera/transmitter module to take photographs of the red-winged starlings, and to transmit this photographs to the receiver module without disturbing the birds' nests. The source code for this subsystem is available in the \href{https://github.com/rothdu/EEE4113F-Group13-2024}{project repository} on GitHub.

Section \ref{s:firmware-requirements} presents a traceability matrix with the subsystem's user requirements, interpretted functional requirements, and the corresponding ATPs. Section \ref{s:firmware-design-decisions} discusses high-level design decisions that informed the subsystem development process. Section \ref{s:firmware-design-process} details the design process and the functionality of the final implementation. Finally, section \ref{s:firmware-atps} shows the acceptance test procedures, proving that the user requirements have been adequately met.

\section{Requirement analysis} \label{s:firmware-requirements}
User requirements (UR) where determined from discussions with the red-winged starling researchers \cite{hofmeyer2024private}. The user requirements were interpretted to form functional requirements (FR) for the subsystem, and subsystem specifications (SS). These are reflected in Table \ref{tab:firmware-requirements}

\begin{table}[!ht]
    \centering
    \begin{scriptsize}
    \begin{tabularx}{\textwidth}{|p{0.13\textwidth} X|}
        
        \hline
        \textbf{UR/FR/SS} & \textbf{Description}\\ \hline
        \textit{UR1} & Triggered with movement\\
        \textit{FR1} & Image capture triggered quickly after PIR sensor reading to see the object that moved\\
        \textit{FR2} & Image capture fast enough to see object that moved\\
        \textit{SS1} & Image capture triggered on PIR sensor high\\ 
        \textit{SS2} & Image captures within 1 second of PIR trigger\\ \hline

        \textit{UR2} & Data access without disturbing nests\\
        \textit{FR3} & A wireless communication protocol must be set up to transfer camera/transmitter data to the receiver\\
        \textit{SS3} & Appropriate two-way communication protocol using WiFi chosen\\
        \textit{SS4} & Protocol transmits all images from the camera/transmitter to the receiver\\ \hline

        \textit{UR3} & Repeated photographs or video footage\\
        \textit{FR4} & Camera must capture multiple time per trigger or take video footage\\
        \textit{SS5} & Module captures a configurable number \textit{n} images each time it is triggered\\ \hline

        \textit{UR4} & Access to images in real time\\
        \textit{FR5} & Tranmission from the camera/transmitter module must be available on-demand from the receiver module\\
        \textit{SS6} & Transmission from the camera/transmitter to the receiver is triggered by a high reading from the RF linker\\ \hline

        \textit{UR5} & Data gathering over 7-week breeding season without frequent camera/transmitter battery changes\\
        \textit{FR6} & Camera/transmitter module must utilise power-saving modes where possible\\
        \textit{SS7} & Camera/transmitter module enters deep sleep mode after finishing image capture or data transmission \\ \hline

        \textit{UR6} & Configurable image quality and trigger frequency\\
        \textit{FR7} & Camera/transmitter module must include remotely updateable configuration options\\
        \textit{SS8} & Camera/transmitter module reads a configuration file in initialisation and loads the appropriate configuration values \\
        \textit{SS9} & New configuration file can be sent from receiver to camera/transmitter which is loaded on next camera/transmitter boot \\ \hline

        \textit{UR7} & Deployment of multiple camera/transmitter modules for different nests\\
        \textit{FR8} & Receiver device must handle separate image storage and configuration options for many camera/transmitter modules\\
        \textit{SS10} & Each module stores and transmits a unique device ID\\
        \textit{SS11} & Receiver module stores a separate folder for data relating to separate deployed modules\\ \hline

    \end{tabularx}
    \end{scriptsize}
    \caption{Requirement and specification analysis for the firmware subsystem}
    \label{tab:firmware-requirements}
\end{table}



\section{High-level design decisions } \label{s:firmware-design-decisions}

This section details high-level design decisions that were made prior to any implementation and testing. These decisions determined key aspects of the development process.

\subsection{Development environment}

Both the ESP32 used for the camera/transmitter and the Raspberry Pi Pico W used for the receiver support a variety of code development environments, including their own native C/C++ frameworks, Arduino, MicroPython and CircuitPython. A summary of the support and features of the various coding frameworks is presented in Table \ref{tab:coding-env}.

\begin{table}[ht]
    \centering
    \begin{scriptsize}
    \begin{tabularx}{0.7\textwidth}{|b{0.08\textwidth}|p{0.2\textwidth}|X|X|X|}
    \hline
    \textbf{Device}                      & \textbf{Environment}        & \textbf{Library support} & \textbf{Online support/userbase} & \textbf{Abstraction level} \\ \hline
    \multirow{4}{0.08\textwidth}{ESP32}              & \color{black} \textit{C/C++ with ESP-IDF} & \color{ForestGreen} Extensive  & \color{ForestGreen} Extensive & \color{red} Low \\ \cline{2-5} 
                                         & \color{black} \textit{Arduino}            & \color{ForestGreen} Extensive  & \color{ForestGreen} Extensive & \color{ForestGreen} Moderate \\ \cline{2-5} 
                                         & \color{black} \textit{MicroPython}        & \color{red} Limited & \color{red} Minimal & \color{CadetBlue} High \\ \cline{2-5} 
                                         & \color{black} \textit{CircuitPython}      & \color{red} Limited & \color{red} Minimal  & \color{CadetBlue} High \\ \hline
    \multirow{5}{0.08\textwidth}{Raspberry Pi Pico W} & \color{black} \textit{Native C/C++ SDK}   & \color{CadetBlue} Moderate  & \color{CadetBlue} Moderate & \color{red} Low\\ \cline{2-5} 
                                         & \color{black} \textit{Official Arduino port}  & \color{CadetBlue} Moderate & \color{CadetBlue} Moderate & \color{ForestGreen} Moderate \\ \cline{2-5} 
                                         & \color{black} \textit{Community Arduino port}  & \color{ForestGreen} Extensive & \color{ForestGreen} Extensive & \color{ForestGreen} Moderate \\ \cline{2-5} 
                                         & \color{black} \textit{MicroPython}        & \color{ForestGreen} Extensive  & \color{ForestGreen} Extensive & \color{CadetBlue} High \\ \cline{2-5} 
                                         & \color{black} \textit{CircuitPython}      & \color{ForestGreen} Extensive & \color{CadetBlue} Moderate & \color{CadetBlue} High \\ \hline
    \end{tabularx}%
    \end{scriptsize}
    \caption{Summary of common coding environments for the available microcontroller}
    \label{tab:coding-env}
\end{table}

With the exception of MicroPython and CircuitPython for the ESP32, the library and online support is likely sufficient for this application. Abstraction level is thus a key consideration. Frameworks with low extraction levels are typically used in professional applications that require fine control over the device hardware. This often makes using these frameworks much more time consuming, unless you have extensive experience with the framework. On the other hand, high abstraction levels sometimes abstract away desired hardware control. A moderate abstraction level is preferred, to strike a balance between these considerations.

Arduino thus emerges as a clear choice for the ESP32. Although MicroPython and CircuitPython may provide all the functionality needed for the the Raspberry Pi Pico W, Arduino was chosen such that the entire project was coded in the same framework, thus requiring knowledge of only the one framework in the current and future iterations of the project.

The Raspbery Pi Pico W supports two Arduino ports - the "official" one, and a community maintained one. Contrary to what might be expected, the community port offers better library and online/user support, as it has been in development for longer; thus, the community port was used.

\subsection{File transfer method}

As described in Chapter , the WiFi was selected as the preffered communication method on a hardware level. Both microcontrollers also support Bluetooth, but this was largely coincidental.
%TODO: Add reference to Thiyashan's section

For data transmission over WiFi, numerous protocols exist, including encrypted and unencrypted protocols. An encrypted protocol was not necessary for this application, as the devices did not transmit sensitive data. The encryption involved inherently makes them more complex and often less efficient; as such, only unencrypted protocols were considered.

Standard unencrypted protocols include User Datagram Protocol (UDP), Tranmission Control Protocol (TCP), File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP). UDP and TCP are low-level protocols; using a standard higher-level prtocol such as FTP or HTTP is more appropriate unless very fine control of data transmission is needed. FTP and HTTP both operate on top of TCP. Of FTP and HTTP, HTTP is much more widely used owing to its use in the World Wide Web, and thus has better library support and documentation, thus it was chosen as the preffered option.

\subsection{Server and client location}

Communication over HTTP is based on a client-server model, where a client sends a request to a known host. It was decided that the camera/transmitter module would act as the client, while the server would be hosted on the receiver. In the current iteration of the project, either device could viably be the server or the client, given HTTP supports two-way communication. 

However, in future iterations of the project, there are particular merits to hosting the server on the receiver device. The server requires a known IP address such that the client knows where to direct it's requests. Once a client has connected to the server, the server sends it's response directly back to whatever client responded to it. The network settings of the UCT campus WiFi do not allow devices to set static IP addresses, meaning it is impossible to host the server on the campus WiFi. If the camera/transmitter acts as the client, it does not need a known IP address when connected to campus WiFi, and could connect to a remotely hosted server. To save power on the camera/transmitter module, it could also be useful to allow the module to immediately initiate connection to the server by acting as the client. 

Aditionally, hosting the server on the receiver device allows for traditional web browsers to remotely connect as a client. This could allow for applications such as updating configuration stored configuration or viewing stored images on the receiver device from a smartphone or laptop.

\subsection{Library selection}

The Arduino framework includes a wide variety of software libraries. These include "standard" libraries, which are integrated into the Arduino framework or the Arduino core for a particular device, and user-supplied libraries which are uploaded by Arduino users. In most cases, the "standard" libraries have the best support and documentation, and are known to be relatively bug-free; as such, "standard" libraries were used for all applications for which they were available.

Some specific library selections falling outside of this general principle were:

\begin{itemize}
    \item ArduinoJson cites 10\% better speed and memory efficiency than the "standard" library, and has extensive documentation available on its website.
    \item ScreenUI  is a user-implemented library for easy development of menus which display on LCD screen, which was applied to the receiver module.
    \item Reference I2C library here...
\end{itemize}

% TODO: reference the libraries I've used



\section{Submodule design} \label{s:firmware-design-process}

\subsection{High level camera/transmitter module firmware flow}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\columnwidth]{"Images/ESP-flow.png"}
    \caption{Flowchart representing the program flow of the ESP32 Camera/Transmitter module}
    \label{fig:espflow}
\end{figure}

Figure \ref{fig:espflow} demonstrates a high-level program flow of the Camera/Transmitter module. The two sequences operate independently. The module has two primary purposes - capturing footage, and transmitting it. Footage capture is Transmission can be triggered manually from the reveiver module, with an interrupt that comes via the RF receiver. 

\subsection{HTTP server API}

The HTTP server implemented on the receiver module or a standalone computer must have available endpoints for all the applications the client wishes to utilise.

\subsection{Camera/transmitter module configuration file}

To meet the identified soft-configurability requirement, the ESP32 module will read a customiseable configuration file to determine a number of key settings. The configuration file is stored in plaintext json at "starling-cam/config/config.json" on the SD card. If the configuration file is unavailable or unreadable, or any configuration parameters are invalid or missing, any missing parameters are loaded as defaults.

This configuration option has a number of advantages:

\begin{itemize}
    \item Storing configuration on the SD card makes it possible to load new configuration options without needing to flash new code onto the ESP32 or access it remotely.
    \item JSON is human-readable format, making easily possible to write new configuration files.
    \item JSON is a well-supported format, and can easily be read and interpretted on the ESP32 using the ArduinoJson library % TODO \ref{arduinoJSON ref here}
\end{itemize}

\subsection{Camera sensor settings}

The user requirements specified that video or image capture was acceptable, though for the latter a number of images in quick succession would be preferable. A key limitation in this regard was the SD card on the camera/transmitter module, which had to be formatted with the FAT32 filesystem in order for the module to interface with it. FAT32 is an older file system which only supports up to 4GB of storage. This storage limitation made still image capture more feasible, especially allowing for the possibility that images would be captured many time each day.

% TODO: Probably some test about file size and a proper analysis of photo vs video

% TODO: A proper analysis of the settings available

\subsection{Camera speed testing}


\section{Acceptance Tests \label{s:firmware-atps}}

The submodule acceptance tests and listed and detailed in Tables \ref{tab:firmware-atps1} and \ref{tab:firmware-atps2}. In all cases, the firmware from the project repository must be flashed to the microcontrollers. In some cases, ATPs use the serial port to display information. The serial port is not used in normal operation as it is not necessary, and conflicts with the switch enable pin for the PIR sensors and RF linker.  In these cases, the ATP specifies to define as specific macro in the code to run the ATP. This, is performed by uncommenting the line in the code titled "\#define ATPx" (where x is the ATP number) prior to flashing the code to the relevant micrcontroller. For ATPs which use the Serial port, the trigger switch (normally connected to GPIO1) be disconnnected from pin 1 and manually pulled high within 5 seconds of triggering the device.

The SD card for the camera/transmitter module should be formatted with the FAT32 filesystem; the SD card for the receiver module should be formatted with the exFAT filesystem. Unless otherwise specified, the storage of both SD cards should be empty prior to starting the test.

\begin{table}[!ht]
    \centering
    \begin{scriptsize}
    \begin{tabularx}{\textwidth}{|p{0.17\textwidth} X|}
        
        \hline
        \textbf{UR/FR/SS} & \textbf{Description}\\ \hline
        \textit{ATP ID} & ATP1\\
        \textit{Related UR/FR/SS} &\\
        \textit{Description} & Photo is captured upon trigger from PIR sensor.\\
        \textit{Procedure} & Standard: Power on the camera/transmitter module. Trigger either PIR sensor once by moving in front of it, or emulate a trigger by manually pulling pins 2 or 4 HIGH. Open the SD card on a computer and observe its contents.\\
        \textit{Acceptance criteria} & 3 photographs are present in the "photos" directory on the SD card.\\ 
        \textit{Pass/fail} & PASS \\ \hline

        \textit{ATP ID} & ATP2 \\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Footage capture is triggered within 1 second.\\
        \textit{Procedure} & Power on the camera/transmitter module. Prepare a stopwatch and orient the camera to view the stopwatch. Simultaneously start the stopwatch and trigger a photo capture as described in ATP1. Open the SD card on a computer and view the first image.\\
        \textit{Acceptance criteria} & Repeat procedure 5 times. The time shown on the stopwatch is less than 1 second in all 5 cases.\\ 
        \textit{Pass/fail} & PASS\\
        \textit{Notes} & The human error from the requirement to simultaneously start the stopwatch and trigger the camera may introduce some error in the reading; however, this error should be sufficiently small compared to the pass criteria to still gain a valid idea of the camera trigger time. \\ \hline

        \textit{ATP ID} & ATP3\\
        \textit{Related UR/FR/SS} &\\
        \textit{Description} & Receiver menu navigation works.\\
        \textit{Procedure} & Power on the receiver module. Navigate the menu using the up, down, confirm, and cancel buttons.\\
        \textit{Acceptance criteria} & Up button scrolls the menu upwards. Down button scrolls the menu downwards. Confirm buttton trigger the currently selected action and, after a brief waiting period, displays an information screen relating to the selected operation. Up and down buttons do not work after selecting confirm. Cancel button returns display to the menu.\\ 
        \textit{Pass/fail} & PASS \\ \hline

        \textit{ATP ID} & ATP4 \\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Camera/transmitter module awakens in transmission mode. \\
        \textit{Procedure} &  Enable the ATP4 macro prior on the camera/transmitter module. Power on the module and monitor the serial port. Power on the receiver module. Navigate the menu and select the "WAKE DEVICE" option.\\
        \textit{Acceptance criteria} & Serial monitor on the camera/transmitter module confirms awoken in transmission mode.\\ 
        \textit{Pass/fail} & PASS\\ \hline

        \textit{ATP ID} & ATP5  \\
        \textit{Related UR/FR/SS} &\\
        \textit{Description} & Metadata is sent over network.\\
        \textit{Procedure} & Trigger the footage capture as described in ATP1 at least 5 times. Open the SD card on a computer, and note the number of images present and the percentage of storage currently used. Power on on the receiver module. Navigate the menu and selelct the "WAKE DEVICE" option. Upon confirmation of connection, select the "SEND METADATA" option.\\
        \textit{Acceptance criteria} & Number of photographs and percentage of storage used displayed on the reciever is the same as the numbers manually observed on the SD card. \\ 
        \textit{Pass/fail} & PASS\\ \hline

        \textit{ATP ID} & ATP6\\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Sample photo is sent over network.\\
        \textit{Procedure} & Power on both modules. Navigate the menu and select the "WAKE DEVICE" option. Upon confirmation of connection, select the "SEND SAMPLE" option. Wait for confirmation of completion. Open the receiver SD card on a computer and observe its contents.\\
        \textit{Acceptance criteria} & A sample image "sample.jpeg" is present in the "cam1" directory on the SD card. \\ 
        \textit{Pass/fail} & PASS \\ \hline

        \textit{ATP ID} & ATP7 \\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & All captured photos are sent over network.\\
        \textit{Procedure} & Power on both modules. Trigger the camera/transmitter module as described in ATP1 at least 10 times. Open the camera/transmitter SD card on a computer and observer its contents. Replace the SD card in the camera/transmitter module. Navigate the menu and select the "WAKE DEVICE" option. Upon completion, select the "SEND PHOTOS" option. Wait for confirmation of completion. Open the receiver SD card on a computer and observe their contents.\\
        \textit{Acceptance criteria} & All images initially present in the "photos" directory of the camera/transmitter module SD card are present in the "cam1" directory of the receiver SD card.\\ 
        \textit{Pass/fail} & PASS \\ \hline
        

    \end{tabularx}
    \end{scriptsize}
    \caption{ATPs 1-7 for the firmware subsystem}
    \label{tab:firmware-atps1}
\end{table}

\begin{table}[!ht]
    \centering
    \begin{scriptsize}
    \begin{tabularx}{\textwidth}{|p{0.17\textwidth} X|}
        
        \hline
        \textbf{UR/FR/SS} & \textbf{Description}\\ \hline

        \textit{ATP ID} & ATP8\\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Configuration options are loaded from SD card.\\
        \textit{Procedure} & Enable the ATP8 macro on the camera/transmitter module. Copy the contents of "config-ATP8-1.json" into "config/config.json" on the SD card. Power on the module trigger it in capture mode following the procedure from ATP1. Observe the outputted exposure level, number of captures per trigger, and time between triggers on the serial monitor. Repeat with "config-ATP8-2.json" \\
        \textit{Acceptance criteria} & First run: outputted values are as specified in the config file. Second run: outputted values are the defaults (1200, 3, 60), since the values from the config file are invalid.\\ 
        \textit{Pass/fail} & PASS\\ \hline
        % TODO: Link github config files

        \textit{ATP ID} & ATP9\\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Update config remotely.\\
        \textit{Procedure} & Power on both modules. Load the contents of "config-ATP9.json" into "cam1/config.json" on the SD card. Navigate the menu and select the "WAKE DEVICE" option. Upon confirmation, select the "UPDATE CONFIG" option. Wait for confirmation. Open the camera/transmitter SD card on a computer and observe its contents.\\
        \textit{Acceptance criteria} & The content of "config/config.json" from the SD card is the same as "config-ATP9.json".\\ 
        \textit{Pass/fail} & PASS \\ \hline

        \textit{ATP ID} & ATP10\\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Receiver/transmitter utilises deep sleep when not in use.\\
        \textit{Procedure} & Power on the camera/transmitter module. Connect an ammeter to the power line of the ESP32 and monitor the current draw. \\
        \textit{Acceptance criteria} & ESP32 current draw is $ < 200 \mu A $ (when not triggered by PIR or RF linker).\\ 
        \textit{Pass/fail} & PASS\\ \hline

        \textit{ATP ID} & ATP10\\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Receiver/transmitter utilises deep sleep when idle.\\
        \textit{Procedure} & Power on the camera/transmitter module. Connect an ammeter to the power line of the ESP32 and monitor the current draw. \\
        \textit{Acceptance criteria} & ESP32 current draw is $ < 200 \mu A $ (when not triggered by PIR or RF linker).\\ 
        \textit{Pass/fail} & PASS\\ \hline

        \textit{ATP ID} & ATP11\\
        \textit{Related UR/FR/SS} & \\
        \textit{Description} & Receiver module can integrate with multiple devices.\\
        \textit{Procedure} & Copy the conents of "config-ATP11.json" to "config/config.json" on the receiver/transmitter SD card. Repeat the procedure described for ATP7. \\
        \textit{Acceptance criteria} & Images are saved to the "cam2" directory rather than the "cam1" directory on the receiver SD card.\\ 
        \textit{Pass/fail} & PASS\\ \hline
        

    \end{tabularx}
    \end{scriptsize}
    \caption{ATPs 8-11 for the firmware subsystem}
    \label{tab:firmware-atps2}
\end{table}