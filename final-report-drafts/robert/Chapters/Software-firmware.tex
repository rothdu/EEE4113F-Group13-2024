% ----------------------------------------------------
% Firmware Submodule
% ----------------------------------------------------
%\documentclass[class=report,11pt,crop=false]{standalone}
%\input{../Style/ChapterStyle.tex}
%\input{../FrontMatter/Glossary.tex}
%\begin{document}
%\ifstandalone
%\tableofcontents
%\fi
% ----------------------------------------------------
\chapter{Firmware \label{ch:firmware}}
% \epigraph{}%
    % {\emph{---Carl Sagan}}
% \vspace{0.5cm}
% ----------------------------------------------------


\section{Subsystem introduction}

\section{Requirement analysis}
The relevant user requirements for this subsystem are shown in table


\begin{itemize}
    \item Video footage ideal, otherwise 3 photos in quick succession
    \item Triggered with movement
    \item Access data without disturbing the nests, possibly with wireless data access
    \item Keep track of noise levels around the nest
    \item Access to the images in "real time" (daily)
    \item Suggested interval of one minute between triggers
    \item Track over the breeding season (7 weeks) without need to change batteries too often
\end{itemize}


\section{Requirement analysis}

\section{Design choices}

\subsection{Choice of development environment}

Both available microcontrollers support a variety of code development environments, including their own native C/C++ with available developer libraries, Arduino, MicroPython and CircuitPython.


% Please add the following required packages to your document preamble:
% \usepackage{multirow}
% \usepackage{graphicx}
\begin{table}[h]
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Device}                      & \textbf{Environment}        & \textbf{Library support} & \textbf{Online support/userbase} & \textbf{Abstraction level} \\ \hline
    \multirow{4}{*}{ESP32}               & \textit{C/C++ with ESP-IDF} & Adequate                 & Moderate (professional)          & Close to hardware          \\ \cline{2-5} 
                                         & \textit{Arduino}            & Extensive and adequate   & Extensive (hobbyist)             & Somewhat abstracted        \\ \cline{2-5} 
                                         & \textit{MicroPython}        & More limited             & Minimal (hobbyist)               & Very high-level            \\ \cline{2-5} 
                                         & \textit{CircuitPython}      & More limited             & Minimal (hobbyist)               & Very high-level            \\ \hline
    \multirow{5}{*}{Raspberry Pi Pico W} & \textit{Native C/C++ SDK}   & Adequate                 & Moderate (professional)          & Close to hardware          \\ \cline{2-5} 
                                         & \textit{Arduino 1}          & Adequate                 & Moderate (hobbyist)              & Somewhat abstracted        \\ \cline{2-5} 
                                         & \textit{Arduino 2}          & Adequate                 & Moderate (hobbyist)              & Somewhat abstracted        \\ \cline{2-5} 
                                         & \textit{MicroPython}        & Extensive and adequate   & Extensive (hobbyist)             & Very high-level            \\ \cline{2-5} 
                                         & \textit{CircuitPython}      & Adequate                 & Moderate (hobbyist)              & Very high-level            \\ \hline
    \end{tabular}%
    }
    \caption{Summary of common coding environments for the available microcontroller}
    \label{tab:coding-env}
    \end{table}

A summary of the support and features of the various coding frameworks is presented in Table \ref{tab:coding-env}.

Coding both microcontrollers using the same framework is a key consideration. This makes the code development process easier both in the current iteration of the project, and for a future engineer who may wish to modify the code, as it requires knowledge of only one framework. 

The bare-metal C/C++ frameworks are used extensively in professional settings for both microcontrollers. The low-level access to hardware can allow advanced configuration of the microcontrollers. However, a consequence of this is that firmware development in these environments tends to be more difficult than more abstracted frameworks. The low-level hardware access was not necessary for the development of this project, and the easier code development of more abstracted environments was thus preferred.

Of the abstracted languages, Arduino has the most library and online user support for the ESP32, while MicroPython has the most support for the Raspberry Pi Pico W.

Arduino was ultimately chosen as the framework for both microcontrollers. The ESP32 in this project requires more complex functionality and was thus prioritised in terms of library and online support. Furthermore, although Arduino is not necessarily well supported on the Pi Pico W specifically, the framework itself has significant online support, and the library support was deemed adequate for this project.

\section{File transfer method}

Both the receiver and transmitter modules support WiFi and Bluetooth. Both protocols are suitable for file transfer.

WiFi was selected as the optimal solution for the following reasons:

\begin{itemize}
    \item Superior range
    \item Superior transfer speeds
    \item Ability to connect to existing network on campus
\end{itemize}

There are two key modes of operation - in one mode, when the nest is outside of the range of UCT WiFi, the devices must connect to each other directly. In the second mode, when the nest is within the range of UCT WiFi, the two devices independently connect to UCT WiFi, to allow for long-range communication. The ability to integrate into the campus network made WiFi a more appealing means of file transfer.

Numerous file transfer protocols exist, including secure(encrypted) and unsecure protocols. A secure protocol is not necessary for this application, as no sensitive data is being transmitted. This makes the added complexity of an encrypted protocol unnecessary.

Standard unencrypted protocols include the File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP). Of these, HTTP is more widely supported and thus easier to implement. It is well supported through standard Arduino libraries.

https://github.com/xreef/SimpleFTPServer


\section{Submodule design}


Things that need to be implemented:
Receiver:

\begin{itemize}
    \item I2C Led display library
    \begin{itemize}
        \item %https://github.com/T-622/RPI-PICO-I2C-LCD/tree/main
        \item %https://github.com/dhylands/python_lcd
        \item %https://github.com/peterhinch/micropython-async/tree/master/v3/as_drivers/hd44780
    \end{itemize}
    \item Pushbutton inputs
    \item \begin{itemize}
        \item Seems to be fine on pi pico
    \end{itemize}
    \item Writing to SD card
    \begin{itemize}
        \item probably just the default arduino SD library
    \end{itemize}
    \item Web server and data reception
    \item RFID transmitter usage
\end{itemize}

Camera:
\begin{itemize}
    \item Read/write from SD card
    \item Read PIR sensors
    \item Read from Camera
    \item Enable infrared flash
    \item Read from RF Receiver
    \item Read temperature \& humidity sensor
    \item Read mic
    \item Connect to web server and transmit data
    \item Transmit data via direct wifi connection
\end{itemize}

Leaning towards Arduino for both - puts the whole project under the same umbrella which would theoretically be useful for future development.
Might be more limited in bare-metal functionality than ESP-IDF, but should be adequate to get the job done. This is not a time-critical application, so it makes sense to go with an option that makes things easy

%https://github.com/earlephilhower/arduino-pico
%https://github.com/arduino/ArduinoCore-mbed
The second link appears to be the "official" one
Porting of pi pico SDK to arduino libraries


Core design decisions:

\begin{itemize}
    \item Choice of programming environment {Arduino, python, pi c++, ESP-IDF}
    \item Choice of Development environment
    \item How to transmit data (WiFi via HTTP? MQTT? Bluetooth?)
    \begin{itemize}
        \item %https://github.com/adafruit/Adafruit_MQTT_Library
    \end{itemize}
    \item Library selection
    \item User interface design
    \item Upload mode to cloud storage
\end{itemize}
% ----------------------------------------------------
\ifstandalone
\bibliography{../Bibliography/References.bib}
\printnoidxglossary[type=\acronymtype,nonumberlist]
\fi
\end{document}
% ----------------------------------------------------